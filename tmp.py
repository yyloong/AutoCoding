# 将字符串保存为 tmp.patch 文件

content = """diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..93a7e1486a 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,310 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        \"\"\"\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        Hash the user's primary key and some user state that's sure to change\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        after a password reset to produce a token that invalidated when it's\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        used:\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        1. The password field will change upon a password reset (even if the\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+           same password is chosen, due to password salting).\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        2. The last_login field will usually be updated very shortly after\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+           a password reset.\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        invalidates the token.\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        Running this data through salted_hmac() prevents password cracking\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        attempts using the reset token, provided the secret isn't compromised.\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        \"\"\"\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +389,7 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change upon email address update.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +399,101 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        # Truncate microseconds so that tokens are consistent even if the\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        # database doesn't support microseconds.\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n         return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+    def _make_hash_value(self, user, timestamp):\n+        \"\"\"\n+        Hash the user's primary key and some user state that's sure to change\n+        after a password reset to produce a token that invalidated when it's\n+        used:\n+        1. The password field will change upon a password reset (even if the\n+           same password is chosen, due to password salting).\n+        2. The last_login field will usually be updated very shortly after\n+           a password reset.\n+        3. The email field will change upon email address update.\n+        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n+        invalidates the token.\n+\n+        Running this data through salted_hmac() prevents password cracking\n+        attempts using the reset token, provided the secret isn't compromised.\n+        \"\"\"\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Include email address to invalidate tokens when email changes\n+        email = getattr(user, 'email', '')\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\n"""

with open("tmp.patch", "w", encoding="utf-8") as file:
    file.write(content)